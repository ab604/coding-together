# Data wrangling II {#data-wrangle-2}

Following on from chapter 2 this lesson deals with some 
common tidying problems with data using the [`tidyr` package](https://tidyr.tidyverse.org/) . By the end of this chapter the learner 
will:

+ have learnt how to transform rows and columns to reorganise data
+ have learnt how to join data contained in separate tables into a single table 
+ have learnt some ways to deal with missing values

## Reshaping data with pivots

As you will recall [tidy data](tidy-data) means that in a table:

1. Every variable has its own column.
2. Every observation has its own row.
3. Each value has its own cell.

Two common problems making your data untidy are that:

1. A single variable is spread across multiple colummns.
2. A single observation is distributed across multiple rows.

In the first case the column names are actually the variable we are 
interested in, making our table **wide**. 

In the second case, the observation is contained in several rows instead
of a single row, making our table **long**.

Hence `tidyr` has functions that **pivot** (as in turning) a table from **wide-to-long** by reducing the number of columns and increasing the number of rows. Or from **long-to-wide** by reducing the number of rows and increasing the number of columns.

Usually, the hard part is identifying in a dataset our variables and our 
observations, as it is not always obvious which is which.

### `tidyr::pivot_longer`

First we'll consider the case when our variable has been recorded as 
column names by returning to a version of the [Portal surveys data](portal-project). 

A table containing the mean weight of 10 rodent species on each plot from the rodent survey data 
can be read directly into a `surveys_spread` object using the code below.

```{r surveys-spread, eval=FALSE}
surveys_spread <- read_csv("https://raw.githubusercontent.com/ab604/ab604.github.io/master/docs/surveys_spread.csv")
```

Feel free to explore the data, and snapshot is shown in Figure \@ref(fig:pivl).

Imagine that we recorded the mean weight of each rodent species on a plot in the field. 
It makes sense to put the species as column headings, along with the plot id and
then record the values in each cell.

However, really our variables of interest are the rodent species and our observational
units, the rows, should contain the mean weight for a rodent species in a plot. Hence we
need to reduce the number of columns and create a longer table.

To do this we `pivot_longer()` by using `names_to = "genus"` to create a new `genus`
variable for the exisiting column heading, and `values_to = "mean_weight"` to create
a variable `mean_weight` for the values. We put a minus sign before the 
variable `-plot_id` to tell the function not to use these values in the new variable column. 

(ref:pivl) `tidyr::pivot_longer`

```{r pivot-long, fig.cap='(ref:pivl)',fig.asp=1, out.width = '100%', fig.align='center', echo=FALSE,cache=TRUE}
knitr::include_graphics("img/pivot_longer_R.png")
```


```{r}
surveys_spread %>% 
        pivot_longer(names_to = "genus", values_to = "mean_weight", -plot_id) 
```

### `tidyr::pivot_wider`

(ref:pivw) `tidyr::pivot_wider`

```{r surveys-gw, eval=FALSE}
surveys_gw <- read_csv("https://raw.githubusercontent.com/ab604/ab604.github.io/master/docs/surveys_grouped_weight.csv")
```


```{r pivot-wider, fig.cap='(ref:pivw)' ,fig.asp=1,out.width = '100%', fig.align='center', echo=FALSE,cache=TRUE}
knitr::include_graphics("img/pivot_wider_R.png")
```

## Missing values

As discussed in [R4DS](https://r4ds.had.co.nz/tidy-data.html#missing-values-3) values can be missing in two ways:

+ **Explicitly**, i.e. flagged with NA.
+ **Implicitly**, i.e. simply not present in the data.

## Joining tables

The `dslabs` package contains a variety of interesting data. 

For example there are two tables, one called `murders` containing the number
of homicides in 2010 for each state in the USA,
and another called `results_us_election_2016` containing the US presidential election
results for 2016 for each state.

Let's take a `glimpse()` at these tables:

```{r dslabs-murders-elections}
# Number of homicides in 2010 for each state in the US
glimpse(murders)
# US presidential election results for 2016 for each state
glimpse(results_us_election_2016)
```

Although these are tables of different data, they both have a `state` variable,
which means we can use that to join them together and combine the datasets.

For example, in the USA the president is elected not through a popular vote, but 
via a process called the electoral college by which
[electoral vote allocation](https://www.archives.gov/federal-register/electoral-college/allocation.html)
is based upon the US census and the population size in each state such that
more populated states have more votes than less populated ones.

We can look at this relationship by joining these two tables, as the `murders`
table contains `population` information for each state and the `results_us_election_2016`
contains the `electoral_votes` for each state.

```{r}
library(scales)
library(ggrepel)
murders %>% inner_join(results_us_election_2016, by = "state") %>% 
        ggplot(aes(x = population, y = electoral_votes,label = abb)) +
        geom_point() +
        geom_text_repel() +
        geom_smooth(method = "lm",se = FALSE) +
        scale_x_log10(labels = comma_format()) +
        scale_y_log10() 
        
        
```


